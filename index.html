<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pipeline d'Analyse Documentaire Multi-Phases - OpenAI</title>
  <link rel="icon" href="data:," />
  <style>
    :root {
      --primary: #2c2622;
      --surface: #faf8f5;
      --card: #f5f2ed;
      --muted: #e8e3db;
      --highlight: #f0eee8;
      --text: #3a352f;
      --accent: #8b7355;
      --accent2: #a68b5b;
      --warm: #d4c4a8;
      --success: #7d8471;
      --warning: #c4986b;
      --error: #b85c57;
      --radius: 12px;
      --gap: 2rem;
      --sp: clamp(1rem, 2.5vw, 1.5rem);
      --fw: 400;
      --mono: 'Fira Code', 'Monaco', 'Consolas', monospace;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }
    
    * {
      box-sizing: border-box;
    }
    
    html, body {
      margin: 0;
      padding: 0;
      background: var(--surface);
      color: var(--text);
      min-height: 100vh;
      font-weight: var(--fw);
      line-height: 1.6;
    }
    
    body {
      display: flex;
      flex-direction: column;
    }
    
    header {
      background: var(--card);
      border-bottom: 1px solid var(--muted);
      padding: var(--sp) 0;
      text-align: center;
    }
    
    h1 {
      font-weight: 600;
      margin: 0;
      font-size: 1.8rem;
      color: var(--accent);
      letter-spacing: -0.02em;
    }
    
    .subtitle {
      font-size: 0.9rem;
      color: var(--accent2);
      margin-top: 0.5rem;
      font-weight: 500;
    }
    
    nav {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }
    
    nav button {
      background: var(--muted);
      border: none;
      border-radius: var(--radius);
      padding: 0.6rem 1.2rem;
      color: var(--text);
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.9rem;
    }
    
    nav button.active {
      background: var(--accent);
      color: var(--surface);
    }
    
    nav button:hover:not(.active) {
      background: var(--warm);
    }
    
    main {
      flex: 1;
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem var(--sp);
      width: 100%;
    }
    
    .section {
      display: none;
      background: var(--card);
      border-radius: var(--radius);
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 2px 8px rgba(60, 50, 40, 0.06);
    }
    
    .section.active {
      display: block;
    }
    
    .upload-zone {
      border: 2px dashed var(--warm);
      border-radius: var(--radius);
      padding: 3rem 2rem;
      text-align: center;
      background: var(--highlight);
      transition: all 0.3s ease;
      cursor: pointer;
      margin-bottom: 2rem;
    }
    
    .upload-zone:hover {
      border-color: var(--accent);
      background: var(--muted);
    }
    
    .upload-zone.dragover {
      border-color: var(--accent2);
      background: var(--warm);
    }
    
    .upload-icon {
      font-size: 3rem;
      color: var(--accent);
      margin-bottom: 1rem;
    }
    
    .upload-text {
      font-size: 1.1rem;
      color: var(--text);
      margin-bottom: 0.5rem;
    }
    
    .upload-subtext {
      font-size: 0.9rem;
      color: var(--accent2);
    }
    
    .file-input {
      display: none;
    }
    
    .progress-container {
      background: var(--muted);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin: 1rem 0;
    }
    
    .progress-bar {
      background: var(--highlight);
      height: 8px;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 1rem;
    }
    
    .progress-fill {
      background: linear-gradient(90deg, var(--accent), var(--accent2));
      height: 100%;
      transition: width 0.3s ease;
      width: 0%;
    }
    
    .phase-list {
      display: grid;
      gap: 1rem;
    }
    
    .phase-item {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      background: var(--surface);
      border-radius: 8px;
      border-left: 4px solid var(--muted);
    }
    
    .phase-item.active {
      border-left-color: var(--accent);
      background: var(--highlight);
    }
    
    .phase-item.completed {
      border-left-color: var(--success);
    }
    
    .phase-item.error {
      border-left-color: var(--error);
    }
    
    .phase-status {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--muted);
      color: var(--text);
      font-size: 0.8rem;
      font-weight: 600;
    }
    
    .phase-status.active {
      background: var(--accent);
      color: var(--surface);
      animation: pulse 2s infinite;
    }
    
    .phase-status.completed {
      background: var(--success);
      color: var(--surface);
    }
    
    .phase-status.error {
      background: var(--error);
      color: var(--surface);
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .btn {
      background: var(--accent);
      color: var(--surface);
      border: none;
      border-radius: var(--radius);
      padding: 0.8rem 1.5rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 0.95rem;
    }
    
    .btn:hover {
      background: var(--accent2);
    }
    
    .btn:disabled {
      background: var(--muted);
      color: var(--accent2);
      cursor: not-allowed;
    }
    
    .btn-secondary {
      background: var(--muted);
      color: var(--text);
    }
    
    .btn-secondary:hover {
      background: var(--warm);
    }
    
    .report-section {
      margin-top: 2rem;
    }
    
    .report-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1.5rem;
    }
    
    .report-title {
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text);
    }
    
    .report-stats {
      display: flex;
      gap: 2rem;
      margin-bottom: 2rem;
    }
    
    .stat-card {
      background: var(--surface);
      padding: 1rem 1.5rem;
      border-radius: var(--radius);
      text-align: center;
      flex: 1;
    }
    
    .stat-number {
      font-size: 2rem;
      font-weight: 700;
      color: var(--accent);
    }
    
    .stat-label {
      font-size: 0.85rem;
      color: var(--accent2);
      margin-top: 0.25rem;
    }
    
    .finding-item {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-bottom: 1rem;
      border-left: 4px solid var(--muted);
    }
    
    .finding-item.warning {
      border-left-color: var(--warning);
    }
    
    .finding-item.error {
      border-left-color: var(--error);
    }
    
    .finding-header {
      display: flex;
      justify-content: between;
      align-items: flex-start;
      margin-bottom: 1rem;
    }
    
    .finding-title {
      font-weight: 600;
      color: var(--text);
      margin-bottom: 0.5rem;
    }
    
    .finding-location {
      font-size: 0.85rem;
      color: var(--accent2);
      font-family: var(--mono);
    }
    
    .finding-content {
      color: var(--text);
      line-height: 1.7;
    }
    
    .tag-container {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      margin-top: 1rem;
    }
    
    .tag {
      background: var(--muted);
      color: var(--text);
      padding: 0.25rem 0.75rem;
      border-radius: 20px;
      font-size: 0.8rem;
      font-weight: 500;
    }
    
    .tag.domain {
      background: var(--accent);
      color: var(--surface);
    }
    
    .tag.concept {
      background: var(--warm);
    }
    
    .loading-spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid var(--muted);
      border-radius: 50%;
      border-top-color: var(--accent);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .grid {
      display: grid;
      gap: 1rem;
    }
    
    .grid-2 {
      grid-template-columns: 1fr 1fr;
    }
    
    @media (max-width: 768px) {
      .grid-2 {
        grid-template-columns: 1fr;
      }
      
      .report-stats {
        flex-direction: column;
        gap: 1rem;
      }
      
      main {
        padding: 1rem;
      }
      
      .section {
        padding: 1.5rem;
      }
    }
    
    .confidence-meter {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }
    
    .confidence-bar {
      flex: 1;
      height: 6px;
      background: var(--muted);
      border-radius: 3px;
      overflow: hidden;
    }
    
    .confidence-fill {
      height: 100%;
      transition: width 0.3s ease;
    }
    
    .confidence-fill.high {
      background: var(--success);
    }
    
    .confidence-fill.medium {
      background: var(--warning);
    }
    
    .confidence-fill.low {
      background: var(--error);
    }
    
    .log-container {
      background: var(--surface);
      border-radius: var(--radius);
      padding: 1rem;
      max-height: 300px;
      overflow-y: auto;
      font-family: var(--mono);
      font-size: 0.85rem;
      margin-top: 1rem;
    }
    
    .log-entry {
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--muted);
    }
    
    .log-entry:last-child {
      border-bottom: none;
    }
    
    .log-timestamp {
      color: var(--accent2);
      margin-right: 1rem;
    }
    
    .config-section {
      background: var(--highlight);
      border: 1px solid var(--muted);
      border-radius: var(--radius);
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    
    .config-input {
      width: 100%;
      padding: 0.8rem;
      border: 1px solid var(--muted);
      border-radius: var(--radius);
      background: var(--surface);
      color: var(--text);
      font-family: var(--mono);
      font-size: 0.9rem;
    }
    
    .config-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(139, 115, 85, 0.1);
    }
    
    .status-indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-left: 0.5rem;
    }
    
    .status-indicator.connected {
      background: var(--success);
    }
    
    .status-indicator.disconnected {
      background: var(--error);
    }
  </style>
</head>
<body>
  <header>
    <h1>Pipeline d'Analyse Documentaire Multi-Phases</h1>
    <div class="subtitle">Syst√®me d'indexation vectorielle et v√©rification crois√©e - OpenAI</div>
    <nav>
      <button class="navtab active" data-tab="upload">üìÑ Import</button>
      <button class="navtab" data-tab="pipeline">‚öôÔ∏è Pipeline</button>
      <button class="navtab" data-tab="analysis">üîç Analyse</button>
      <button class="navtab" data-tab="reports">üìä Rapports</button>
      <button class="navtab" data-tab="vectors">üß† Index Vectoriel</button>
    </nav>
  </header>

  <main>
    <!-- UPLOAD SECTION -->
    <section id="tab-upload" class="section active">
      <div class="config-section">
        <h4>Configuration OpenAI</h4>
        <div style="margin-bottom: 1rem;">
          <label for="openai-key" style="display: block; margin-bottom: 0.5rem; font-weight: 500;">
            Cl√© API OpenAI <span class="status-indicator disconnected" id="api-status"></span>
          </label>
          <input 
            type="password" 
            id="openai-key" 
            class="config-input" 
            placeholder="sk-..." 
            autocomplete="off"
          >
          <div style="font-size: 0.85rem; color: var(--accent2); margin-top: 0.5rem;">
            Votre cl√© API est stock√©e localement et n'est jamais transmise ailleurs qu'√† OpenAI
          </div>
        </div>
        <button class="btn btn-secondary" id="test-api">Tester la Connexion</button>
      </div>
      
      <div class="grid grid-2">
        <div>
          <h3>Document Principal</h3>
          <div class="upload-zone" id="main-doc-zone">
            <div class="upload-icon">üìÑ</div>
            <div class="upload-text">D√©posez votre document principal</div>
            <div class="upload-subtext">PDF, DOCX, TXT - jusqu'√† 300 pages</div>
            <input type="file" id="main-doc-input" class="file-input" accept=".pdf,.docx,.txt">
          </div>
          <div id="main-doc-status"></div>
        </div>
        
        <div>
          <h3>Documents de R√©f√©rence</h3>
          <div class="upload-zone" id="ref-docs-zone">
            <div class="upload-icon">üìö</div>
            <div class="upload-text">D√©posez vos r√©f√©rences</div>
            <div class="upload-subtext">PDF multiples - jusqu'√† 200 documents</div>
            <input type="file" id="ref-docs-input" class="file-input" accept=".pdf" multiple>
          </div>
          <div id="ref-docs-status"></div>
        </div>
      </div>
      
      <div style="text-align: center; margin-top: 2rem;">
        <button class="btn" id="start-analysis" disabled>D√©marrer l'Analyse</button>
      </div>
    </section>

    <!-- PIPELINE SECTION -->
    <section id="tab-pipeline" class="section">
      <h3>Progression du Pipeline</h3>
      
      <div class="progress-container">
        <div class="progress-bar">
          <div class="progress-fill" id="overall-progress"></div>
        </div>
        <div style="text-align: center; color: var(--accent2); font-size: 0.9rem;" id="progress-text">
          En attente de documents...
        </div>
      </div>
      
      <div class="phase-list">
        <div class="phase-item" id="phase-1">
          <div class="phase-status">1</div>
          <div>
            <div class="phase-title" style="font-weight: 600;">Extraction et Indexation Initiale</div>
            <div style="font-size: 0.9rem; color: var(--accent2);">Extraction des entit√©s, concepts et valeurs num√©riques</div>
          </div>
        </div>
        
        <div class="phase-item" id="phase-2">
          <div class="phase-status">2</div>
          <div>
            <div class="phase-title" style="font-weight: 600;">Construction des Bases Vectorielles</div>
            <div style="font-size: 0.9rem; color: var(--accent2);">G√©n√©ration d'embeddings et indexation s√©mantique</div>
          </div>
        </div>
        
        <div class="phase-item" id="phase-3">
          <div class="phase-status">3</div>
          <div>
            <div class="phase-title" style="font-weight: 600;">Analyse Crois√©e Multi-Sources</div>
            <div style="font-size: 0.9rem; color: var(--accent2);">V√©rification des affirmations contre les r√©f√©rences</div>
          </div>
        </div>
        
        <div class="phase-item" id="phase-4">
          <div class="phase-status">4</div>
          <div>
            <div class="phase-title" style="font-weight: 600;">Validation et Synth√®se</div>
            <div style="font-size: 0.9rem; color: var(--accent2);">G√©n√©ration du rapport final et scores de confiance</div>
          </div>
        </div>
      </div>
      
      <div class="log-container" id="pipeline-logs">
        <div class="log-entry">
          <span class="log-timestamp">--:--:--</span>
          <span>Syst√®me initialis√©. En attente de documents...</span>
        </div>
      </div>
    </section>

    <!-- ANALYSIS SECTION -->
    <section id="tab-analysis" class="section">
      <h3>Analyse en Cours</h3>
      
      <div class="report-stats">
        <div class="stat-card">
          <div class="stat-number" id="entities-count">0</div>
          <div class="stat-label">Entit√©s Extraites</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="segments-count">0</div>
          <div class="stat-label">Segments Analys√©s</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="verifications-count">0</div>
          <div class="stat-label">V√©rifications</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="issues-count">0</div>
          <div class="stat-label">Probl√®mes D√©tect√©s</div>
        </div>
      </div>
      
      <div id="current-analysis">
        <div style="text-align: center; color: var(--accent2); padding: 2rem;">
          Aucune analyse en cours
        </div>
      </div>
    </section>

    <!-- REPORTS SECTION -->
    <section id="tab-reports" class="section">
      <div class="report-header">
        <h3 class="report-title">Rapport d'Analyse</h3>
        <div>
          <button class="btn btn-secondary" id="export-report">Exporter PDF</button>
        </div>
      </div>
      
      <div id="report-content">
        <div style="text-align: center; color: var(--accent2); padding: 3rem;">
          Aucun rapport disponible. Lancez une analyse pour voir les r√©sultats.
        </div>
      </div>
    </section>

    <!-- VECTORS SECTION -->
    <section id="tab-vectors" class="section">
      <h3>Index Vectoriel et Navigation Contextuelle</h3>
      
      <div class="grid grid-2">
        <div>
          <h4>Domaines Identifi√©s</h4>
          <div id="domains-list">
            <div style="color: var(--accent2); padding: 1rem;">
              Aucun domaine d√©tect√©
            </div>
          </div>
        </div>
        
        <div>
          <h4>Navigation par Tags</h4>
          <div id="tags-navigation">
            <div style="color: var(--accent2); padding: 1rem;">
              Aucun tag g√©n√©r√©
            </div>
          </div>
        </div>
      </div>
      
      <div style="margin-top: 2rem;">
        <h4>Recherche S√©mantique</h4>
        <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
          <input type="text" id="semantic-search" placeholder="Rechercher des concepts, valeurs, relations..." 
                 style="flex: 1; padding: 0.8rem; border: 1px solid var(--muted); border-radius: var(--radius); background: var(--surface);">
          <button class="btn" id="search-btn">Rechercher</button>
        </div>
        <div id="search-results"></div>
      </div>
    </section>
  </main>

  <script>
    // Global state
    let analysisState = {
      apiKey: '',
      apiConnected: false,
      mainDocument: null,
      referenceDocuments: [],
      currentPhase: 0,
      vectorIndex: new Map(),
      analysisResults: {},
      entityCount: 0,
      segmentCount: 0,
      verificationCount: 0,
      issueCount: 0
    };

    // OpenAI API Configuration
    function initializeAPI() {
      const savedKey = localStorage.getItem('openai-api-key');
      if (savedKey) {
        analysisState.apiKey = savedKey;
        document.getElementById('openai-key').value = savedKey;
        testAPIConnection();
      }
    }

    document.getElementById('openai-key').addEventListener('input', (e) => {
      const key = e.target.value.trim();
      analysisState.apiKey = key;
      if (key) {
        localStorage.setItem('openai-api-key', key);
      } else {
        localStorage.removeItem('openai-api-key');
      }
      updateAPIStatus(false);
    });

    document.getElementById('test-api').addEventListener('click', testAPIConnection);

    async function testAPIConnection() {
      if (!analysisState.apiKey) {
        alert('Veuillez entrer votre cl√© API OpenAI');
        return;
      }

      try {
        const response = await fetch('https://api.openai.com/v1/models', {
          headers: {
            'Authorization': `Bearer ${analysisState.apiKey}`,
            'Content-Type': 'application/json'
          }
        });

        if (response.ok) {
          updateAPIStatus(true);
          logMessage('‚úÖ Connexion OpenAI √©tablie avec succ√®s');
        } else {
          updateAPIStatus(false);
          logMessage('‚ùå Erreur de connexion OpenAI: Cl√© API invalide');
        }
      } catch (error) {
        updateAPIStatus(false);
        logMessage(`‚ùå Erreur de connexion OpenAI: ${error.message}`);
      }
    }

    function updateAPIStatus(connected) {
      analysisState.apiConnected = connected;
      const indicator = document.getElementById('api-status');
      indicator.className = `status-indicator ${connected ? 'connected' : 'disconnected'}`;
      checkStartButton();
    }

    // Navigation
    document.querySelectorAll('.navtab').forEach(btn => {
      btn.addEventListener('click', e => {
        document.querySelectorAll('.navtab').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
        document.getElementById('tab-' + btn.dataset.tab).classList.add('active');
      });
    });

    // File upload handlers
    function setupFileUpload(zoneId, inputId, callback) {
      const zone = document.getElementById(zoneId);
      const input = document.getElementById(inputId);
      
      zone.addEventListener('click', () => input.click());
      zone.addEventListener('dragover', e => {
        e.preventDefault();
        zone.classList.add('dragover');
      });
      zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
      zone.addEventListener('drop', e => {
        e.preventDefault();
        zone.classList.remove('dragover');
        const files = e.dataTransfer.files;
        if (files.length > 0) {
          input.files = files;
          callback(files);
        }
      });
      
      input.addEventListener('change', e => callback(e.target.files));
    }

    setupFileUpload('main-doc-zone', 'main-doc-input', handleMainDocument);
    setupFileUpload('ref-docs-zone', 'ref-docs-input', handleReferenceDocuments);

    function handleMainDocument(files) {
      if (files.length > 0) {
        analysisState.mainDocument = files[0];
        updateFileStatus('main-doc-status', files);
        checkStartButton();
        logMessage(`Document principal charg√©: ${files[0].name}`);
      }
    }

    function handleReferenceDocuments(files) {
      analysisState.referenceDocuments = Array.from(files);
      updateFileStatus('ref-docs-status', files);
      checkStartButton();
      logMessage(`${files.length} documents de r√©f√©rence charg√©s`);
    }

    function updateFileStatus(statusId, files) {
      const status = document.getElementById(statusId);
      if (files.length) {
        const fileList = Array.from(files).map(f => 
          `<div style="margin: 0.5rem 0; padding: 0.5rem; background: var(--surface); border-radius: 6px;">
            üìÑ ${f.name} (${formatFileSize(f.size)})
          </div>`
        ).join('');
        status.innerHTML = fileList;
      } else {
        status.innerHTML = '';
      }
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 B';
      const k = 1024;
      const sizes = ['B', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function checkStartButton() {
      const startBtn = document.getElementById('start-analysis');
      const canStart = analysisState.mainDocument && 
                      analysisState.referenceDocuments.length > 0 && 
                      analysisState.apiConnected;
      startBtn.disabled = !canStart;
      if (canStart) {
        startBtn.textContent = `Analyser 1 document principal + ${analysisState.referenceDocuments.length} r√©f√©rences`;
      } else if (!analysisState.apiConnected) {
        startBtn.textContent = 'Configurer OpenAI d\'abord';
      }
    }

    // Pipeline execution
    document.getElementById('start-analysis').addEventListener('click', startAnalysisPipeline);

    async function startAnalysisPipeline() {
      document.getElementById('start-analysis').disabled = true;
      switchToTab('pipeline');
      
      try {
        await executePhase1();
        await executePhase2();
        await executePhase3();
        await executePhase4();
        
        logMessage('‚úÖ Analyse termin√©e avec succ√®s');
        switchToTab('reports');
      } catch (error) {
        logMessage(`‚ùå Erreur durant l'analyse: ${error.message}`);
        markPhaseError(analysisState.currentPhase);
      }
    }

    async function executePhase1() {
      analysisState.currentPhase = 1;
      markPhaseActive(1);
      updateProgress(10, 'Phase 1: Extraction et indexation...');
      
      logMessage('üîç D√©but de l\'extraction des entit√©s...');
      
      // Extract from main document
      const mainContent = await extractDocumentContent(analysisState.mainDocument);
      const entities = await extractEntities(mainContent);
      
      analysisState.entityCount = entities.length;
      updateStat('entities-count', entities.length);
      
      // Extract from reference documents
      let refEntities = [];
      for (let i = 0; i < analysisState.referenceDocuments.length; i++) {
        const doc = analysisState.referenceDocuments[i];
        logMessage(`üìö Traitement r√©f√©rence ${i + 1}/${analysisState.referenceDocuments.length}: ${doc.name}`);
        const content = await extractDocumentContent(doc);
        const docEntities = await extractEntities(content);
        refEntities = refEntities.concat(docEntities.map(e => ({...e, source: doc.name})));
        
        updateProgress(10 + (i / analysisState.referenceDocuments.length) * 15, 
                      `Extraction r√©f√©rence ${i + 1}/${analysisState.referenceDocuments.length}`);
      }
      
      analysisState.mainEntities = entities;
      analysisState.referenceEntities = refEntities;
      
      markPhaseCompleted(1);
      logMessage(`‚úÖ Phase 1 termin√©e: ${entities.length} entit√©s principales, ${refEntities.length} entit√©s de r√©f√©rence`);
    }

    async function executePhase2() {
      analysisState.currentPhase = 2;
      markPhaseActive(2);
      updateProgress(25, 'Phase 2: Construction des bases vectorielles...');
      
      logMessage('üß† G√©n√©ration des embeddings...');
      
      // Create vector embeddings for all entities
      const allEntities = [...analysisState.mainEntities, ...analysisState.referenceEntities];
      
      for (let i = 0; i < allEntities.length; i++) {
        const entity = allEntities[i];
        const embedding = await generateEmbedding(entity.text);
        analysisState.vectorIndex.set(entity.id, {
          ...entity,
          embedding: embedding,
          vector_id: entity.id
        });
        
        if (i % 50 === 0) {
          updateProgress(25 + (i / allEntities.length) * 25, 
                        `Embeddings ${i}/${allEntities.length}`);
        }
      }
      
      markPhaseCompleted(2);
      logMessage(`‚úÖ Phase 2 termin√©e: ${analysisState.vectorIndex.size} embeddings g√©n√©r√©s`);
    }

    async function executePhase3() {
      analysisState.currentPhase = 3;
      markPhaseActive(3);
      updateProgress(50, 'Phase 3: Analyse crois√©e...');
      
      logMessage('üîç D√©but de l\'analyse crois√©e des sources...');
      
      const segments = segmentDocument(analysisState.mainEntities);
      analysisState.segmentCount = segments.length;
      updateStat('segments-count', segments.length);
      
      const verifications = [];
      
      for (let i = 0; i < segments.length; i++) {
        const segment = segments[i];
        logMessage(`üîç Analyse segment ${i + 1}/${segments.length}`);
        
        const verification = await performCrossVerification(segment);
        verifications.push(verification);
        
        analysisState.verificationCount++;
        updateStat('verifications-count', analysisState.verificationCount);
        
        if (verification.issues.length > 0) {
          analysisState.issueCount += verification.issues.length;
          updateStat('issues-count', analysisState.issueCount);
        }
        
        updateProgress(50 + (i / segments.length) * 25, 
                      `Analyse segment ${i + 1}/${segments.length}`);
      }
      
      analysisState.verifications = verifications;
      
      markPhaseCompleted(3);
      logMessage(`‚úÖ Phase 3 termin√©e: ${verifications.length} segments v√©rifi√©s`);
    }

    async function executePhase4() {
      analysisState.currentPhase = 4;
      markPhaseActive(4);
      updateProgress(75, 'Phase 4: Validation et synth√®se...');
      
      logMessage('üìä G√©n√©ration du rapport final...');
      
      const report = await generateFinalReport();
      analysisState.finalReport = report;
      
      // Update UI with results
      displayReport(report);
      displayDomains(report.domains);
      displayTags(report.tags);
      
      updateProgress(100, 'Analyse termin√©e');
      markPhaseCompleted(4);
      logMessage(`‚úÖ Analyse compl√®te termin√©e`);
    }

    // API Functions using OpenAI
    async function callOpenAI(messages, options = {}) {
      if (!analysisState.apiKey) {
        throw new Error('Cl√© API OpenAI non configur√©e');
      }

      const payload = {
        model: options.model || 'gpt-4',
        messages: messages,
        max_tokens: options.maxTokens || 2000,
        temperature: options.temperature || 0.1,
        ...options
      };

      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${analysisState.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

      if (!response.ok) {
        const error = await response.json();
        throw new Error(`OpenAI API Error: ${error.error?.message || response.statusText}`);
      }

      const result = await response.json();
      return result.choices[0].message.content;
    }

    async function extractDocumentContent(file) {
      logMessage(`üìÑ Extraction du contenu: ${file.name}`);
      
      // Convert file to text (simplified - in real implementation would handle PDF/DOCX properly)
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          resolve(e.target.result);
        };
        reader.readAsText(file);
      });
    }

    async function extractEntities(content) {
      const messages = [{
        role: 'system',
        content: `Vous √™tes un expert en analyse documentaire. Analysez le texte fourni et extrayez toutes les entit√©s importantes selon ce format JSON:
        {
          "entities": [
            {
              "id": "entity_1",
              "text": "texte exact de l'entit√©",
              "type": "concept|valeur|√©quation|r√©f√©rence|affirmation",
              "context": "contexte imm√©diat",
              "position": "position approximative"
            }
          ]
        }`
      }, {
        role: 'user',
        content: `Analysez ce texte et extrayez toutes les entit√©s importantes:\n\n${content.substring(0, 8000)}...`
      }];

      try {
        const result = await callOpenAI(messages, { maxTokens: 2000 });
        const parsed = JSON.parse(result);
        return parsed.entities || [];
      } catch (error) {
        logMessage(`‚ö†Ô∏è Erreur extraction entit√©s: ${error.message}`);
        return [];
      }
    }

    async function generateEmbedding(text) {
      try {
        const response = await fetch('https://api.openai.com/v1/embeddings', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${analysisState.apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'text-embedding-3-small',
            input: text
          })
        });

        if (!response.ok) {
          throw new Error(`Embedding API Error: ${response.statusText}`);
        }

        const result = await response.json();
        return result.data[0].embedding;
      } catch (error) {
        logMessage(`‚ö†Ô∏è Erreur g√©n√©ration embedding: ${error.message}`);
        // Fallback to simple hash-based vector
        return simpleHashVector(text);
      }
    }

    function simpleHashVector(text) {
      const words = text.toLowerCase().split(/\s+/);
      const vector = new Array(384).fill(0);
      
      words.forEach((word, i) => {
        const hash = simpleHash(word);
        vector[hash % 384] += 1;
      });
      
      // Normalize vector
      const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
      return vector.map(val => magnitude > 0 ? val / magnitude : 0);
    }

    function simpleHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    }

    function segmentDocument(entities) {
      // Group entities into logical segments
      const segments = [];
      const segmentSize = 20;
      
      for (let i = 0; i < entities.length; i += segmentSize) {
        segments.push({
          id: `segment_${Math.floor(i / segmentSize)}`,
          entities: entities.slice(i, i + segmentSize),
          startIndex: i,
          endIndex: Math.min(i + segmentSize, entities.length)
        });
      }
      
      return segments;
    }

    async function performCrossVerification(segment) {
      logMessage(`üîç V√©rification crois√©e segment ${segment.id}`);
      
      const issues = [];
      const confidenceScores = [];
      
      // Find similar entities in reference documents
      for (const entity of segment.entities) {
        const similarRefs = findSimilarEntities(entity, analysisState.referenceEntities);
        
        if (similarRefs.length === 0) {
          issues.push({
            type: 'warning',
            entity: entity,
            message: 'Aucune r√©f√©rence trouv√©e pour v√©rifier cette affirmation',
            confidence: 0.3
          });
        } else {
          // Verify consistency
          const verification = await verifyEntityConsistency(entity, similarRefs);
          if (!verification.consistent) {
            issues.push({
              type: 'error',
              entity: entity,
              message: verification.reason,
              references: similarRefs,
              confidence: verification.confidence
            });
          }
          confidenceScores.push(verification.confidence);
        }
      }
      
      const avgConfidence = confidenceScores.length > 0 
        ? confidenceScores.reduce((a, b) => a + b, 0) / confidenceScores.length 
        : 0.5;
      
      return {
        segment: segment,
        issues: issues,
        confidence: avgConfidence,
        verified: issues.length === 0
      };
    }

    function findSimilarEntities(targetEntity, referenceEntities) {
      const similarities = [];
      const targetVector = analysisState.vectorIndex.get(targetEntity.id)?.embedding;
      
      if (!targetVector) return [];
      
      for (const refEntity of referenceEntities) {
        const refVector = analysisState.vectorIndex.get(refEntity.id)?.embedding;
        if (refVector) {
          const similarity = cosineSimilarity(targetVector, refVector);
          if (similarity > 0.7) { // Threshold for similarity
            similarities.push({
              entity: refEntity,
              similarity: similarity
            });
          }
        }
      }
      
      return similarities.sort((a, b) => b.similarity - a.similarity).slice(0, 5);
    }

    function cosineSimilarity(vecA, vecB) {
      let dotProduct = 0;
      let normA = 0;
      let normB = 0;
      
      for (let i = 0; i < vecA.length; i++) {
        dotProduct += vecA[i] * vecB[i];
        normA += vecA[i] * vecA[i];
        normB += vecB[i] * vecB[i];
      }
      
      return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
    }

    async function verifyEntityConsistency(entity, similarRefs) {
      const messages = [{
        role: 'system',
        content: `Vous √™tes un expert en v√©rification de coh√©rence documentaire. Analysez l'affirmation et les r√©f√©rences pour d√©terminer la coh√©rence.
        R√©pondez en JSON avec ce format:
        {
          "consistent": true/false,
          "reason": "explication d√©taill√©e",
          "confidence": 0.8
        }`
      }, {
        role: 'user',
        content: `V√©rifiez la coh√©rence de cette affirmation avec les r√©f√©rences fournies:

Affirmation: "${entity.text}"

R√©f√©rences:
${similarRefs.map((ref, i) => `${i + 1}. ${ref.entity.text} (Source: ${ref.entity.source})`).join('\n')}`
      }];

      try {
        const result = await callOpenAI(messages, { maxTokens: 500 });
        const evaluation = JSON.parse(result);
        
        return {
          consistent: evaluation.consistent,
          reason: evaluation.reason,
          confidence: evaluation.confidence
        };
      } catch (error) {
        return {
          consistent: false,
          reason: 'Erreur lors de la v√©rification',
          confidence: 0.1
        };
      }
    }

    async function generateFinalReport() {
      logMessage('üìä Compilation du rapport final...');
      
      const domains = extractDomains();
      const tags = generateTags();
      const summary = await generateSummary();
      
      return {
        timestamp: new Date().toISOString(),
        summary: summary,
        domains: domains,
        tags: tags,
        statistics: {
          totalEntities: analysisState.entityCount,
          totalSegments: analysisState.segmentCount,
          totalVerifications: analysisState.verificationCount,
          totalIssues: analysisState.issueCount
        },
        verifications: analysisState.verifications
      };
    }

    function extractDomains() {
      const domains = new Set();
      
      analysisState.mainEntities.forEach(entity => {
        // Simplified domain detection
        if (entity.text.toLowerCase().includes('math')) domains.add('Math√©matiques');
        if (entity.text.toLowerCase().includes('phys')) domains.add('Physique');
        if (entity.text.toLowerCase().includes('bio')) domains.add('Biologie');
        if (entity.text.toLowerCase().includes('chem')) domains.add('Chimie');
        if (entity.text.toLowerCase().includes('√©co')) domains.add('√âconomie');
      });
      
      return Array.from(domains);
    }

    function generateTags() {
      const tags = new Map();
      
      analysisState.mainEntities.forEach(entity => {
        const entityTags = extractTagsFromEntity(entity);
        entityTags.forEach(tag => {
          if (!tags.has(tag)) {
            tags.set(tag, []);
          }
          tags.get(tag).push(entity.id);
        });
      });
      
      return tags;
    }

    function extractTagsFromEntity(entity) {
      const tags = [];
      const text = entity.text.toLowerCase();
      
      // Extract numerical values
      const numbers = text.match(/\d+(?:\.\d+)?/g);
      if (numbers) {
        numbers.forEach(num => tags.push(`valeur:${num}`));
      }
      
      // Extract key concepts
      const words = text.split(/\s+/).filter(word => word.length > 3);
      words.forEach(word => tags.push(`concept:${word}`));
      
      return tags;
    }

    async function generateSummary() {
      const messages = [{
        role: 'system',
        content: 'Vous √™tes un expert en synth√®se documentaire. Cr√©ez un r√©sum√© concis et informatif de l\'analyse effectu√©e.'
      }, {
        role: 'user',
        content: `G√©n√©rez un r√©sum√© de cette analyse documentaire:
        - ${analysisState.entityCount} entit√©s analys√©es
        - ${analysisState.segmentCount} segments trait√©s
        - ${analysisState.verificationCount} v√©rifications effectu√©es
        - ${analysisState.issueCount} probl√®mes d√©tect√©s
        
        Taux d'erreur: ${analysisState.verificationCount > 0 ? (analysisState.issueCount / analysisState.verificationCount * 100).toFixed(1) : 0}%`
      }];

      try {
        return await callOpenAI(messages, { maxTokens: 300 });
      } catch (error) {
        return `Analyse de ${analysisState.entityCount} entit√©s sur ${analysisState.segmentCount} segments. 
                ${analysisState.issueCount} probl√®mes d√©tect√©s sur ${analysisState.verificationCount} v√©rifications.`;
      }
    }

    // UI Update Functions
    function switchToTab(tabName) {
      document.querySelector(`[data-tab="${tabName}"]`).click();
    }

    function updateProgress(percentage, text) {
      document.getElementById('overall-progress').style.width = `${percentage}%`;
      document.getElementById('progress-text').textContent = text;
    }

    function markPhaseActive(phaseNum) {
      const phase = document.getElementById(`phase-${phaseNum}`);
      phase.classList.add('active');
      phase.querySelector('.phase-status').classList.add('active');
    }

    function markPhaseCompleted(phaseNum) {
      const phase = document.getElementById(`phase-${phaseNum}`);
      phase.classList.remove('active');
      phase.classList.add('completed');
      phase.querySelector('.phase-status').classList.remove('active');
      phase.querySelector('.phase-status').classList.add('completed');
      phase.querySelector('.phase-status').innerHTML = '‚úì';
    }

    function markPhaseError(phaseNum) {
      const phase = document.getElementById(`phase-${phaseNum}`);
      phase.classList.remove('active');
      phase.classList.add('error');
      phase.querySelector('.phase-status').classList.remove('active');
      phase.querySelector('.phase-status').classList.add('error');
      phase.querySelector('.phase-status').innerHTML = '‚úó';
    }

    function updateStat(statId, value) {
      document.getElementById(statId).textContent = value.toLocaleString();
    }

    function logMessage(message) {
      const logs = document.getElementById('pipeline-logs');
      const timestamp = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<span class="log-timestamp">${timestamp}</span><span>${message}</span>`;
      logs.insertBefore(entry, logs.firstChild);
      
      // Keep only last 20 entries
      while (logs.children.length > 20) {
        logs.removeChild(logs.lastChild);
      }
    }

    function displayReport(report) {
      const reportContent = document.getElementById('report-content');
      
      let html = `
        <div class="report-stats">
          <div class="stat-card">
            <div class="stat-number">${report.statistics.totalEntities}</div>
            <div class="stat-label">Entit√©s Analys√©es</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${report.statistics.totalIssues}</div>
            <div class="stat-label">Probl√®mes D√©tect√©s</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${report.statistics.totalVerifications}</div>
            <div class="stat-label">V√©rifications</div>
          </div>
          <div class="stat-card">
            <div class="stat-number">${((1 - report.statistics.totalIssues / report.statistics.totalVerifications) * 100).toFixed(1)}%</div>
            <div class="stat-label">Taux de Confiance</div>
          </div>
        </div>
        
        <div style="margin: 2rem 0;">
          <h4>R√©sum√© Ex√©cutif</h4>
          <p>${report.summary}</p>
        </div>
        
        <h4>Probl√®mes D√©tect√©s</h4>
      `;
      
      if (report.verifications && report.verifications.length > 0) {
        report.verifications.forEach((verification, index) => {
          verification.issues.forEach(issue => {
            html += `
              <div class="finding-item ${issue.type}">
                <div class="finding-header">
                  <div class="finding-title">${issue.message}</div>
                  <div class="finding-location">Segment ${verification.segment.id}</div>
                </div>
                <div class="finding-content">
                  <strong>Entit√©:</strong> ${issue.entity.text}
                  ${issue.references ? `<br><strong>R√©f√©rences:</strong> ${issue.references.map(r => r.entity.source).join(', ')}` : ''}
                </div>
                <div class="confidence-meter">
                  <span style="font-size: 0.85rem;">Confiance:</span>
                  <div class="confidence-bar">
                    <div class="confidence-fill ${getConfidenceClass(issue.confidence)}" 
                         style="width: ${issue.confidence * 100}%"></div>
                  </div>
                  <span style="font-size: 0.85rem;">${(issue.confidence * 100).toFixed(0)}%</span>
                </div>
              </div>
            `;
          });
        });
      } else {
        html += '<div style="text-align: center; color: var(--success); padding: 2rem;">Aucun probl√®me d√©tect√©</div>';
      }
      
      reportContent.innerHTML = html;
    }

    function getConfidenceClass(confidence) {
      if (confidence >= 0.7) return 'high';
      if (confidence >= 0.4) return 'medium';
      return 'low';
    }

    function displayDomains(domains) {
      const domainsList = document.getElementById('domains-list');
      
      if (domains.length > 0) {
        domainsList.innerHTML = domains.map(domain => 
          `<div class="tag domain" style="margin: 0.5rem 0;">${domain}</div>`
        ).join('');
      } else {
        domainsList.innerHTML = '<div style="color: var(--accent2); padding: 1rem;">Aucun domaine d√©tect√©</div>';
      }
    }

    function displayTags(tags) {
      const tagsNav = document.getElementById('tags-navigation');
      
      if (tags.size > 0) {
        let html = '';
        tags.forEach((entityIds, tag) => {
          html += `<div class="tag concept" style="margin: 0.25rem; cursor: pointer;" 
                        onclick="searchByTag('${tag}')">${tag} (${entityIds.length})</div>`;
        });
        tagsNav.innerHTML = html;
      } else {
        tagsNav.innerHTML = '<div style="color: var(--accent2); padding: 1rem;">Aucun tag g√©n√©r√©</div>';
      }
    }

    function searchByTag(tag) {
      document.getElementById('semantic-search').value = tag;
      performSemanticSearch();
    }

    // Semantic search
    document.getElementById('search-btn').addEventListener('click', performSemanticSearch);
    document.getElementById('semantic-search').addEventListener('keypress', e => {
      if (e.key === 'Enter') performSemanticSearch();
    });

    function performSemanticSearch() {
      const query = document.getElementById('semantic-search').value;
      const results = document.getElementById('search-results');
      
      if (!query.trim()) {
        results.innerHTML = '';
        return;
      }
      
      // Simplified search - in real implementation would use proper vector similarity
      const matchingEntities = [];
      
      if (analysisState.mainEntities) {
        analysisState.mainEntities.forEach(entity => {
          if (entity.text.toLowerCase().includes(query.toLowerCase())) {
            matchingEntities.push(entity);
          }
        });
      }
      
      if (matchingEntities.length > 0) {
        let html = '<h5>R√©sultats de Recherche</h5>';
        matchingEntities.slice(0, 10).forEach(entity => {
          html += `
            <div class="finding-item">
              <div class="finding-content">${entity.text}</div>
              <div class="tag-container">
                <div class="tag">${entity.type}</div>
              </div>
            </div>
          `;
        });
        results.innerHTML = html;
      } else {
        results.innerHTML = '<div style="color: var(--accent2); padding: 1rem;">Aucun r√©sultat trouv√©</div>';
      }
    }

    // Export functionality
    document.getElementById('export-report').addEventListener('click', exportReport);

    function exportReport() {
      if (!analysisState.finalReport) {
        alert('Aucun rapport √† exporter. Lancez d\'abord une analyse.');
        return;
      }
      
      // Generate text report
      let reportText = `RAPPORT D'ANALYSE DOCUMENTAIRE\n`;
      reportText += `Generated: ${new Date().toISOString()}\n\n`;
      reportText += `R√âSUM√â:\n${analysisState.finalReport.summary}\n\n`;
      reportText += `STATISTIQUES:\n`;
      reportText += `- Entit√©s: ${analysisState.finalReport.statistics.totalEntities}\n`;
      reportText += `- Segments: ${analysisState.finalReport.statistics.totalSegments}\n`;
      reportText += `- V√©rifications: ${analysisState.finalReport.statistics.totalVerifications}\n`;
      reportText += `- Probl√®mes: ${analysisState.finalReport.statistics.totalIssues}\n\n`;
      
      if (analysisState.finalReport.verifications) {
        reportText += `PROBL√àMES D√âTECT√âS:\n`;
        analysisState.finalReport.verifications.forEach((verification, i) => {
          verification.issues.forEach((issue, j) => {
            reportText += `${i + 1}.${j + 1} ${issue.message}\n`;
            reportText += `    Entit√©: ${issue.entity.text}\n`;
            reportText += `    Confiance: ${(issue.confidence * 100).toFixed(0)}%\n\n`;
          });
        });
      }
      
      // Download as text file
      const blob = new Blob([reportText], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `rapport_analyse_${new Date().toISOString().split('T')[0]}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      initializeAPI();
      logMessage('üöÄ Syst√®me d\'analyse documentaire initialis√© avec OpenAI');
    });
  </script>
</body>
</html>
